// Copyright 2019 Splitted-Desktop Systems. All rights reserved
// Copyright 2019 Julien Viard de Galbert
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Gotest process JSON stream generated by `go test -json` or `test2json`.
//
// Usage:
//
//	gotestlive [go test -json]
//
package main

import (
	"flag"
	"fmt"
	"io"
	"log"
	"net/http"
	"net/http/httputil"
	"net/url"
	"os"

	"github.com/JulienVdG/tastevin/pkg/browser"
	"github.com/JulienVdG/tastevin/pkg/gotest"
	"github.com/JulienVdG/tastevin/pkg/gotestweb"
	"github.com/JulienVdG/tastevin/pkg/json2test"
	"github.com/JulienVdG/tastevin/pkg/xio"
)

var (
	flagP = flag.Bool("p", false, "proxy for dev")
	flagL = flag.Bool("l", false, "local files for prereleases")
	flagV = flag.Bool("v", false, "verbose test output (like go test -v)")
	flagS = flag.Bool("s", false, "silent (ie no test output)")
)

func setHTTPHandlers() {
	// TODO param for proxy
	if *flagP {
		rpURL, err := url.Parse("http://localhost:3000/")
		if err != nil {
			log.Fatal(err)
		}
		http.Handle("/", httputil.NewSingleHostReverseProxy(rpURL))
	} else if *flagL {
		http.Handle("/", http.FileServer(http.Dir("../gotest-web/gotest-web2/dist/")))
	} else {
		err := gotestweb.Handle()
		if err != nil {
			log.Fatal(err)
		}
	}
	http.Handle("/single/", http.StripPrefix("/single/", http.FileServer(http.Dir("logs/"))))

}

func main() {
	flag.Parse()
	var c io.WriteCloser
	setHTTPHandlers()
	l := gotestweb.HandleLive()
	errc := make(chan error, 1)
	go func() {
		log.Fatal(http.ListenAndServe(":8080", nil))
		errc <- nil
	}()
	browser.Open("http://localhost:8080/#build?live&asciicast=single&summary")
	if !*flagS {
		var h json2test.TestEventHandler
		if *flagV {
			h = json2test.NewVerboseHandler(os.Stdout)
		} else {
			h = json2test.NewSummaryHandler(os.Stdout)
		}

		c = json2test.NewConverter(h)
		c = xio.MultiWriteCloser(l, c)
	} else {
		c = l
	}
	args := flag.Args()
	err := gotest.Run(c, args)
	fmt.Printf("gotestlive: test done.\n")

	<-errc // Wait for http.ListenAndServe end
	if err != nil {
		os.Exit(1)
	}
}
