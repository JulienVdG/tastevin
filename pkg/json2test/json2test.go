// Copyright 2019 Splitted-Desktop Systems. All rights reserved
// Copyright 2019 Julien Viard de Galbert
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Package json2test decodes JSON output from test2json.
//
// See the cmd/test2json documentation for details of the JSON encoding.
package json2test

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io"
	"log"
	"time"
)

// Exported to allow testing
var (
	LogDebug  = func(string, ...interface{}) {}
	LogWarn   = log.Printf
	OutPrintf = fmt.Printf
)

// TestEvent is the decoded JSON as generated by `test2json` or `go test -json`
type TestEvent struct {
	Time    *time.Time `json:",omitempty"`
	Action  string
	Package string   `json:",omitempty"`
	Test    string   `json:",omitempty"`
	Elapsed *float64 `json:",omitempty"`
	Output  string   `json:",omitempty"`
}

// TestEventHandler do the processing of TestEvent during conversion.
type TestEventHandler interface {
	Handle(e TestEvent)
}

type converter struct {
	h []TestEventHandler
}

// NewConverter returns a "json to test" converter.
// Writes on the returned writer are decoded and given to the TestEventHandlers.
func NewConverter(h ...TestEventHandler) io.WriteCloser {
	c := new(converter)
	*c = converter{
		h: h,
	}
	return c
}

// Write writes the test input to the converter.
func (c *converter) Write(b []byte) (int, error) {
	for _, line := range bytes.Split(b, []byte("\n")) {
		LogDebug("json2test line:%q", line)
		if len(line) == 0 {
			continue
		}
		var e TestEvent
		err := json.Unmarshal(line, &e)
		if err != nil {
			nonspaceOffset := int64(bytes.IndexFunc(line, func(c rune) bool {
				return c > ' '
			})) + 1
			jsonErr, ok := err.(*json.SyntaxError)
			if ok && jsonErr.Offset == nonspaceOffset {
				// Non decoded full line, probably an error
				// display it
				OutPrintf("%s\n", line)
				continue
			}
			LogWarn("json2test Unmarshal: %s", err)
			continue
		}
		for _, h := range c.h {
			h.Handle(e)
		}
	}
	return len(b), nil
}

// Close does nothing but allow to use the converter as a io.WriteCloser
func (c *converter) Close() error {
	return nil
}
