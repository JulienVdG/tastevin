// Copyright 2019 Splitted-Desktop Systems. All rights reserved
// Copyright 2019 Julien Viard de Galbert
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Gotest process JSON stream generated by `go test -json` or `test2json`.
//
// Usage:
//
//	gotest <run|live|serve|gen> [go test -json]
//
package main

import (
	"errors"
	"flag"
	"fmt"
	"io"
	"log"
	"net/http"
	"net/http/httputil"
	"net/url"
	"os"
	"path/filepath"
	"strings"

	rice "github.com/GeertJohan/go.rice"
	"github.com/JulienVdG/tastevin/pkg/browser"
	"github.com/JulienVdG/tastevin/pkg/gotestweb"
	"github.com/JulienVdG/tastevin/pkg/json2test"
	"github.com/JulienVdG/tastevin/pkg/testsuite"
	"github.com/JulienVdG/tastevin/pkg/xio"
)

func usage() {
	fmt.Fprintf(flag.CommandLine.Output(), "Usage: gotest [flags] <run|live|serve|gen> [go test -json]\n")
	fmt.Fprintf(flag.CommandLine.Output(), "  run\trun the test and save outputs\n")
	fmt.Fprintf(flag.CommandLine.Output(), "  live\trun the test, save outputs and serve them in browser\n")
	fmt.Fprintf(flag.CommandLine.Output(), "  serve\tserve the given test output in browser\n")
	fmt.Fprintf(flag.CommandLine.Output(), "  gen\trender the given test for external web server\n\n")
	flag.PrintDefaults()
	os.Exit(2)
}

var (
	flagL   = flag.String("l", "logs/", "set the log directory, also passed to tastevin config")
	flagJ   = flag.String("j", "results.json", "set JSON `filename` inside log directory")
	flagV   = flag.Bool("v", false, "verbose test output (like go test -v)")
	flagS   = flag.Bool("s", false, "silent (ie no test output)")
	flagP   = flag.String("p", "", "dev: proxy to gotestweb (typical \"http://localhost:3000/\")")
	flagT   = flag.String("t", "", "dev: test path to gotestweb (typical \"pkg/gotestweb/webapp/dist/\")")
	flagH   = flag.String("o", "", "set the html output directory (default \"output/\" for gen)")
	flagI   = flag.String("i", "index.html", "set the html output filename")
	appURL  = flag.String("app", "", "gen: External URL to find GoTestWeb")
	flagCDN = flag.Bool("cdn", false, "gen: use CDN url for bootstrap and jquery")
)

func main() {
	var doRun, live, doServe, doGen bool
	flag.Usage = usage
	flag.Parse()
	if flag.NArg() == 0 {
		usage()
	}
	args := flag.Args()
	switch args[0] {
	case "run":
		doRun = true
		if *flagH != "" {
			doGen = true
		}
	case "live":
		doRun = true
		live = true
		doServe = true
	case "serve":
		doServe = true
	case "gen":
		doGen = true
	default:
		usage()
	}

	var l io.WriteCloser
	serveDone := make(chan struct{}, 1)
	if doServe {
		var err error
		l, err = serve(live, serveDone)
		if err != nil {
			fmt.Println(err)
			os.Exit(1)
		}
	}

	var runerr error
	if doRun {
		runerr = run(l, args[1:])
	}
	if live {
		fmt.Printf("gotest live: test done.\n")
	}

	if doServe {
		// Wait for http.ListenAndServe end
		<-serveDone
	}

	if doGen {
		err := gen()
		if err != nil {
			fmt.Println(err)
			os.Exit(1)
		}
	}

	if runerr != nil {
		if _, ok := runerr.(RunError); !ok {
			fmt.Println(runerr)
		}
		os.Exit(1)
	}
}

func setHTTPHandlers() (string, error) {
	if *flagP != "" {
		rpURL, err := url.Parse(*flagP)
		if err != nil {
			return "", err
		}
		http.Handle("/", httputil.NewSingleHostReverseProxy(rpURL))
	} else if *flagT != "" {
		http.Handle("/", http.FileServer(http.Dir(*flagT)))
	} else {
		err := gotestweb.Handle()
		if err != nil {
			return "", err
		}
	}
	slug := filepath.Base(*flagL)
	prefix := "/" + slug + "/"

	http.Handle(prefix, http.StripPrefix(prefix, http.FileServer(http.Dir(*flagL))))
	return slug, nil
}

func serve(live bool, done chan struct{}) (io.WriteCloser, error) {
	var l io.WriteCloser
	slug, err := setHTTPHandlers()
	if err != nil {
		return nil, err
	}
	if live {
		l = gotestweb.HandleLive()
	}
	go func() {
		log.Fatal(http.ListenAndServe(":8080", nil))
		done <- struct{}{}
	}()
	url := "http://localhost:8080/#"
	if live {
		url += slug + "/?live&summary=1"
	} else {
		url += slug + "/" + *flagJ + "?asciicast=" + slug + "&scriptreplay=" + slug + "&summary=0"
	}
	browser.Open(url)
	return l, nil
}

func run(l io.WriteCloser, args []string) error {
	var c io.WriteCloser

	// Update env
	absdir, err := filepath.Abs(*flagL)
	if err != nil {
		return fmt.Errorf("error getting absolute path '%s': %v", *flagL, err)
	}
	err = testsuite.SetConfLogDir(absdir + "/")
	if err != nil {
		return fmt.Errorf("error updating config: %v", err)
	}

	if !*flagS {
		var h json2test.TestEventHandler
		if *flagV {
			h = json2test.NewVerboseHandler(os.Stdout)
		} else {
			h = json2test.NewSummaryHandler(os.Stdout)
		}

		c = json2test.NewConverter(h)
	}
	if *flagJ != "" {
		jsonfilename := filepath.Join(absdir, *flagJ)
		dir := filepath.Dir(jsonfilename)
		err := os.MkdirAll(dir, 0775)
		if err != nil {
			return fmt.Errorf("error creating directory '%s': %v", dir, err)
		}

		f, err := os.Create(jsonfilename)
		if err != nil {
			return fmt.Errorf("error creating file '%s': %v", *flagJ, err)
		}
		if l == nil {
			if *flagS {
				c = f
			} else {
				c = xio.MultiWriteCloser(c, f)
			}
		} else {
			if *flagS {
				c = xio.MultiWriteCloser(l, f)
			} else {
				c = xio.MultiWriteCloser(l, c, f)
			}
		}
	} else if *flagS {
		if l == nil {
			return errors.New("error -j is required in silent mode")
		}
		c = l
	}

	if len(args) == 0 {
		io.Copy(c, os.Stdin)
		c.Close()
		return nil
	}
	return Run(c, args)
}

func gen() error {
	if *flagH == "" {
		*flagH = "output/"
	}
	outdir, err := filepath.Abs(*flagH)
	if err != nil {
		return fmt.Errorf("error getting absolute path '%s': %v", *flagH, err)
	}
	err = os.MkdirAll(outdir, 0775)
	if err != nil {
		return fmt.Errorf("error creating directory '%s': %v", outdir, err)
	}
	logdir, err := filepath.Abs(*flagL)
	if err != nil {
		return fmt.Errorf("error getting absolute path '%s': %v", *flagL, err)
	}

	var slug, jsonfile string
	if !strings.HasPrefix(logdir+"/", outdir+"/") {
		slug = filepath.Base(*flagL)
		jsonfile = slug + "/" + *flagJ
		// copy logs if logdir is not inside output dir
		outlogdir := filepath.Join(outdir, slug)
		e := filepath.Walk(logdir, func(path string, f os.FileInfo, err error) error {
			if err != nil { // Don't try to fix walk issues
				return err
			}
			relpath, err := filepath.Rel(logdir, path)
			if err != nil {
				return err
			}
			target := filepath.Join(outlogdir, relpath)
			return copyItemTo(path, target, f, nil)
		})
		if e != nil {
			return e
		}
	} else {
		// logdir is inside output dir, rebuild path
		slug, err = filepath.Rel(outdir+"/", logdir+"/")
		if err != nil {
			return err
		}

		if slug == "." && *flagJ == filepath.Base(*flagJ) {
			slug = ""
			jsonfile = *flagJ
		} else {
			jsonfile = slug + "/" + *flagJ
		}
	}

	// use template to generate index
	indexfilename := filepath.Join(outdir, *flagI)
	f, err := os.Create(indexfilename)
	if err != nil {
		return fmt.Errorf("error creating file '%s': %v", *flagI, err)
	}
	defer f.Close()
	data := gotestweb.IndexData{
		File:         jsonfile,
		Asciicast:    slug,
		Scriptreplay: slug,
		AppPrefix:    *appURL,
		UseCDN:       *flagCDN,
	}
	gotestweb.WriteIndex(f, data)

	if *appURL == "" {
		box, err := gotestweb.RiceBox()
		if err != nil {
			return err
		}
		e := box.Walk("", func(path string, f os.FileInfo, err error) error {
			if err != nil { // Don't try to fix walk issues
				return err
			}
			// skip index, we generated it anyway
			if path == "index.html" {
				return nil
			}
			// skip box root
			if f.Name() == "http-files" {
				return nil
			}
			if *flagCDN {
				// skip cdn components
				switch path {
				case "vendor/bootstrap", "vendor/jquery":
					return filepath.SkipDir
				}
			}
			target := filepath.Join(outdir, path)
			return copyItemTo(path, target, f, box)
		})
		if e != nil {
			return e
		}
	}
	return nil
}

func copyItemTo(src, dst string, srcfi os.FileInfo, box *rice.Box) error {
	m := srcfi.Mode()
	//fmt.Println(src, dst, m.IsDir(), m.Perm())
	if m.IsDir() {
		return os.MkdirAll(dst, 0775)
	}
	if !m.IsRegular() {
		return fmt.Errorf("unsupported file mode %s", m)
	}
	return copyRegularFile(src, dst, srcfi, box)
}

func copyRegularFile(src, dst string, srcfi os.FileInfo, box *rice.Box) error {
	var srcf io.Reader
	if box == nil {
		f, err := os.Open(src)
		if err != nil {
			return err
		}
		defer f.Close()
		srcf = f
	} else {
		f, err := box.Open(src)
		if err != nil {
			return err
		}
		defer f.Close()
		srcf = f
	}

	dstf, err := os.OpenFile(dst, os.O_RDWR|os.O_CREATE|os.O_TRUNC, srcfi.Mode().Perm())
	if err != nil {
		return err
	}
	defer dstf.Close()

	_, err = io.Copy(dstf, srcf)
	return err
}
